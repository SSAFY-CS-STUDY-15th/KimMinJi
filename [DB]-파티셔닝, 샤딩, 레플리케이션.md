## 파티셔닝 (Partitioning)

큰 테이블을 더 작은 단위의 테이블로 나누는 것을 의미합니다.

### 수직 파티셔닝 (Vertical Partitioning)

컬럼(Column)을 기준으로 테이블을 나누는 방식입니다.

- 정규화 과정도 일종의 수직 파티셔닝이라 볼 수 있습니다.
- 자주 사용되지 않거나 크기가 매우 큰 컬럼(예: 게시글 본문)을 별도 테이블로 분리하여 I/O 부하를 줄이고 성능을 개선합니다. 민감한 정보에 대한 접근 제한 목적으로도 사용됩니다.

### 수평 파티셔닝 (Horizontal Partitioning)

행(Row)을 기준으로 테이블을 나누는 방식입니다.

- 테이블의 스키마는 그대로 유지됩니다.
- 데이터 양이 많아져 인덱스 크기가 커지고 성능이 저하되는 문제를 해결하기 위해 사용합니다.
- 파티션 키(Partition Key)를 사용하여 데이터를 균등하게 분배하는 것이 중요하며, 해시 기반 방식 등이 주로 사용됩니다.

## 샤딩 (Sharding)

수평 파티셔닝과 유사하지만, 나누어진 각 파티션을 서로 다른 독립된 DB 서버에 저장하는 방식입니다.
단일 DB 서버의 리소스(CPU, 메모리 등) 한계를 극복하고 트래픽 부하를 여러 서버로 분산시키기 위해 사용합니다.

- 샤드(Shard): 분산되어 저장된 각각의 파티션
- 샤드 키(Shard Key): 데이터를 나눌 기준이 되는 키(기준 컬럼)

### 샤딩 방식

#### 1. 모듈러(Modular) 샤딩

PK를 샤드의 개수로 나머지 연산(%)을 하여 데이터를 나누는 방식입니다.

PK 값이 0, 1, 2인 각 데이터가 있고 샤드의 개수가 2개이면, PK가 0, 2인 데이터는 샤드 1에, PK가 1인 데이터는 샤드 2에 배치된다고 생각하면 됩니다.

- 장점: 데이터가 여러 샤드에 비교적 균일하게 분산되어 서버의 부하를 골고루 나눌 수 있음
- 단점: 샤드를 추가로 증설할 경우 나머지 연산의 기준값이 바뀌므로 기존 데이터의 대규모 재배치가 필요

#### 2. 범위 기반(Range) 샤딩

샤드키의 값의 범위를 기준으로 데이터를 나누는 방식입니다.

1~1000번은 1번 샤드, 1001~2000번은 2번 샤드와 같이 샤드 별로 값의 범위를 지정하고 범위에 해당하는 샤드키를 가진 데이터는 해당 샤드로 배정됩니다.

- 장점: 구현이 매우 간단하며, 특정 범위의 데이터를 조회할 때(Range Scan) 효율적
- 단점: 특정 범위에 데이터가 몰릴 경 특정 서버만 부하가 심해질 수 있음

#### 3. 해쉬(Hash) 샤딩

샤드키 값을 해시 함수(Hash Function)에 넣어서 나온 결과값을 기준으로 데이터를 나누는 방식입니다.

- 장점: 모듈러 샤딩처럼 데이터가 매우 균등하게 분산
- 단점: 해시 함수 결과값이 무작위이므로, 특정 범위의 데이터를 한꺼번에 조회하는 쿼리에서 성능이 떨어짐

#### 4. 목록 기반(List) 샤딩

샤드키가 가질 수 있는 값의 목록을 특정 샤드에 할당하는 방식입니다.

예를 들어 국적 목록으로 생각해보면 한국, 일본 고객데이터는 샤드 1번에, 미국, 영국 고객 데이터는 샤드 2번에 배정할 수 있습니다.

- 장점: 비즈니스 로직에 따라 데이터를 물리적으로 분리하기 좋으며 관리 측면에서 명확
- 단점: 특정 목록에 따라 데이터 불균형이 생길 수 있음

#### 5. 디렉터리 기반(Directory) 샤딩

어떤 데이터가 어느 샤드에 있는지 관리하는 별도의 조회용 테이블(Look-up Table)을 두는 방식

- 장점: 데이터를 옮기고 싶을 때 디렉터리 테이블의 위치 정보만 수정하면 되므로 매우 유연. 동적으로 샤드를 추가하기 쉬움
- 단점: 모든 쿼리가 먼저 '디렉터리 테이블'을 거쳐야 하므로 이 테이블이 병목 지점이 되거나, 테이블이 망가질 경우 전체 시스템에 장애가 생기는 단일 장애점(SPOF)이 될 수 있음

## 레플리케이션 (Replication)

데이터베이스를 복제하여 여러 대의 DB 서버에 동일한 데이터를 저장하는 방식입니다.

- Master/Primary/Leader: 실제 쓰기(Write)와 읽기(Read)가 발생하는 주 서버. 부하가 많은 환경에서 성능 향상과 데이터 일관성을 위해 읽기 전용으로 사용하기도 함
- Slave/Secondary/Replica: 마스터로부터 데이터를 복제하여 유지하는 보조 서버

### 장점

- 주 서버에 장애가 발생해도 보조 서버를 통해 서비스를 계속 유지할 수 있음(고가용성(High Availability, HA))
- 부하 분산: 읽기 요청(Read)을 여러 대의 레플리카 서버로 분산시켜 전체적인 성능을 높일 수 있음
- 비동기 방식으로 데이터를 동기화하기 때문에 지연 시간이 거의 없음

### 단점

- 노드들 간의 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할 수 있음
- 데이터 양이 많을 경우 데이터를 찾는데 오랜 시간이 걸릴 수 있음
- 마스터 노드 장애 시 복구&대처가 까다로움

### 레플리케이션 vs 클러스터링

레플리케이션과 클러스터링은 모두 여러 대의 DB 서버에 동일한 데이터를 저장하는 방식입니다. 레플리케이션이 비동기 방식으로 데이터를 동기화하는 것과 달리 클러스터링은 동기 방식으로 데이터를 동기화합니다.

클러스터링 방식은 active-acive 방식과 active-standby 방식이 있습니다.

- active-active: 여러 대의 DB서버를 active 상태로 두어 동시 운용하는 방식
- active-standby: 한 대의 서버를 active, 나머지 서버를 standby 로 두고 active 서버가 중단되는 경우 standby를 active로 전환 하는 방식

## 분산 환경에서의 트랜잭션 유지
이런 분산 환경에서는 트랜잭션을 어떻게 유지할까요? 대표적인 방법으로는 2PC 패턴과 SAGA패턴이 있습니다.

2PC 패턴은 Coordinator 라는 분산 트랜잭션을 관리하는 주체가 있고 2개의 Phase를 통해 트랜잭션을 유지하려고 합니다. Coordinator는  Prepare Phase에서 각 DB가 요청을 처리할 수 있는지를 확인하고 Commit Phase에서 모든 DB가 요청을 처리할 수 있는 상태라고 응답을 보내면 Commit을, 단 한개라도 요청을 처리할 수 없다면 Rollback을 진행합니다.

SAGA 패턴은 MSA나 대규모 분산 환경에서 많이 쓰이는 방식으로 실패 시 되돌리는 작업을 진행하는 방식입니다.

둘의 장단점까지 비교하면 너무 긴 내용이 될 것 같아 다음에 더 자세하게 다루도록 하겠습니다.


## 그래서.. 래플리케이션 vs 샤딩
개인적으로 생각해본 바로는 레플리케이션은 읽기가 많은 경우에 유리합니다. 마스터 서버에서 쓰기를 담당하고 슬레이브 서버에서 읽기를 담당하기 때문에 읽기가 많은 경우 슬레이브 서버를 늘려 부담을 줄여주는 것이 가능합니다.

샤딩은 쓰기가 많은 경우에 유리합니다. 결국 레플리케이션에서 쓰기는 마스터 서버에서 관리하기 때문에 쓰기가 많은 서비스라면 샤딩을 도입하는 것이 좋아보입니다.

사실 대규모 서비스에서는 레플리케이션과 샤딩을 섞어서 쓰는 경우가 많다고 합니다. 하지만 일반적인 토이 프로젝트에서 둘 중 하나를 택1 하라고 한다면 레플리케이션을 고를 것 같습니다. 일반적으로 쓰기보다 읽기가 더 빈번하게 발생할 뿐 아니라 레플리케이션을 사용하면 페일오버를 통한 가용성 이점도 챙길 수 있기 때문입니다.